{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
  // same ids are connected.
  // Example:
  "codeforces": {
    "prefix": "codeforces",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "using ld = long double;",
      "using uint = unsigned int;",
      "using ull = unsigned long long;",
      "template <typename T>",
      "using pii = pair<T, T>;",
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll myRand(ll B)",
      "{",
      "    return (ull)rng() % B;",
      "}",
      "",
      "#define All(a) a.begin(), a.end()",
      "#define rep(i, x, n) for (int i = x; i < n; i++)",
      "#define pb push_back",
      "#define fastio                        \\",
      "    ios_base::sync_with_stdio(false); \\",
      "    cin.tie(NULL);                    \\",
      "    cout.tie(NULL)",
      "",
      "void solve()",
      "{",
      "\t$0",
      "}",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    int t;",
      "    cin >> t;",
      "    while (t--)",
      "        solve();",
      "    return 0;",
      "}"
    ],
    "description": "Codeforces basic snippet"
  },
  "atcoder": {
    "prefix": "atcoder",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "using ld = long double;",
      "using uint = unsigned int;",
      "using ull = unsigned long long;",
      "template <typename T>",
      "using pii = pair<T, T>;",
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll myRand(ll B)",
      "{",
      "    return (ull)rng() % B;",
      "}",
      "",
      "#define All(a) a.begin(), a.end()",
      "#define rep(i, x, n) for (int i = x; i < n; i++)",
      "#define pb push_back",
      "#define fastio                        \\",
      "    ios_base::sync_with_stdio(false); \\",
      "    cin.tie(NULL);                    \\",
      "    cout.tie(NULL)",
      "",
      "void solve()",
      "{",
      "\t$0",
      "}",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    solve();",
      "    return 0;",
      "}"
    ],
    "description": "Atcoder basic snippet"
  },
  "kickstart": {
    "prefix": "kickstart",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "using ld = long double;",
      "using uint = unsigned int;",
      "using ull = unsigned long long;",
      "template <typename T>",
      "using pii = pair<T, T>;",
      "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll myRand(ll B)",
      "{",
      "    return (ull)rng() % B;",
      "}",
      "",
      "#define All(a) a.begin(), a.end()",
      "#define rep(i, x, n) for (int i = x; i < n; i++)",
      "#define pb push_back",
      "#define fastio                        \\",
      "    ios_base::sync_with_stdio(false); \\",
      "    cin.tie(NULL);                    \\",
      "    cout.tie(NULL)",
      "",
      "void solve()",
      "{",
      "\t$0",
      "}",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    int t;",
      "    cin >> t;",
      "    for (int i = 1; i <= t; i++)",
      "    {",
      "        cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Kickstart/Codejam/FBHackerCup basic snippet"
  },
  "boilerplate": {
    "prefix": "boilerplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main()",
      "{",
      "    return 0;",
      "}"
    ],
    "description": "Most Generic Snippet"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "#ifdef _MSC_VER",
      "#include <intrin.h>",
      "#endif",
      "",
      "#include <utility>",
      "",
      "#ifdef _MSC_VER",
      "#include <intrin.h>",
      "#endif",
      "",
      "namespace izano",
      "{",
      "",
      "    namespace internal",
      "    {",
      "",
      "        constexpr long long safe_mod(long long x, long long m)",
      "        {",
      "            x %= m;",
      "            if (x < 0)",
      "                x += m;",
      "            return x;",
      "        }",
      "",
      "        struct barrett",
      "        {",
      "            unsigned int _m;",
      "            unsigned long long im;",
      "",
      "            explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
      "",
      "            unsigned int umod() const { return _m; }",
      "",
      "            unsigned int mul(unsigned int a, unsigned int b) const",
      "            {",
      "",
      "                unsigned long long z = a;",
      "                z *= b;",
      "#ifdef _MSC_VER",
      "                unsigned long long x;",
      "                _umul128(z, im, &x);",
      "#else",
      "                unsigned long long x =",
      "                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
      "#endif",
      "                unsigned int v = (unsigned int)(z - x * _m);",
      "                if (_m <= v)",
      "                    v += _m;",
      "                return v;",
      "            }",
      "        };",
      "",
      "        constexpr long long pow_mod_constexpr(long long x, long long n, int m)",
      "        {",
      "            if (m == 1)",
      "                return 0;",
      "            unsigned int _m = (unsigned int)(m);",
      "            unsigned long long r = 1;",
      "            unsigned long long y = safe_mod(x, m);",
      "            while (n)",
      "            {",
      "                if (n & 1)",
      "                    r = (r * y) % _m;",
      "                y = (y * y) % _m;",
      "                n >>= 1;",
      "            }",
      "            return r;",
      "        }",
      "",
      "        constexpr bool is_prime_constexpr(int n)",
      "        {",
      "            if (n <= 1)",
      "                return false;",
      "            if (n == 2 || n == 7 || n == 61)",
      "                return true;",
      "            if (n % 2 == 0)",
      "                return false;",
      "            long long d = n - 1;",
      "            while (d % 2 == 0)",
      "                d /= 2;",
      "            constexpr long long bases[3] = {2, 7, 61};",
      "            for (long long a : bases)",
      "            {",
      "                long long t = d;",
      "                long long y = pow_mod_constexpr(a, t, n);",
      "                while (t != n - 1 && y != 1 && y != n - 1)",
      "                {",
      "                    y = y * y % n;",
      "                    t <<= 1;",
      "                }",
      "                if (y != n - 1 && t % 2 == 0)",
      "                {",
      "                    return false;",
      "                }",
      "            }",
      "            return true;",
      "        }",
      "        template <int n>",
      "        constexpr bool is_prime = is_prime_constexpr(n);",
      "",
      "        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)",
      "        {",
      "            a = safe_mod(a, b);",
      "            if (a == 0)",
      "                return {b, 0};",
      "",
      "            long long s = b, t = a;",
      "            long long m0 = 0, m1 = 1;",
      "",
      "            while (t)",
      "            {",
      "                long long u = s / t;",
      "                s -= t * u;",
      "                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b",
      "",
      "                auto tmp = s;",
      "                s = t;",
      "                t = tmp;",
      "                tmp = m0;",
      "                m0 = m1;",
      "                m1 = tmp;",
      "            }",
      "            if (m0 < 0)",
      "                m0 += b / s;",
      "            return {s, m0};",
      "        }",
      "",
      "        constexpr int primitive_root_constexpr(int m)",
      "        {",
      "            if (m == 2)",
      "                return 1;",
      "            if (m == 167772161)",
      "                return 3;",
      "            if (m == 469762049)",
      "                return 3;",
      "            if (m == 754974721)",
      "                return 11;",
      "            if (m == 998244353)",
      "                return 3;",
      "            int divs[20] = {};",
      "            divs[0] = 2;",
      "            int cnt = 1;",
      "            int x = (m - 1) / 2;",
      "            while (x % 2 == 0)",
      "                x /= 2;",
      "            for (int i = 3; (long long)(i)*i <= x; i += 2)",
      "            {",
      "                if (x % i == 0)",
      "                {",
      "                    divs[cnt++] = i;",
      "                    while (x % i == 0)",
      "                    {",
      "                        x /= i;",
      "                    }",
      "                }",
      "            }",
      "            if (x > 1)",
      "            {",
      "                divs[cnt++] = x;",
      "            }",
      "            for (int g = 2;; g++)",
      "            {",
      "                bool ok = true;",
      "                for (int i = 0; i < cnt; i++)",
      "                {",
      "                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)",
      "                    {",
      "                        ok = false;",
      "                        break;",
      "                    }",
      "                }",
      "                if (ok)",
      "                    return g;",
      "            }",
      "        }",
      "        template <int m>",
      "        constexpr int primitive_root = primitive_root_constexpr(m);",
      "",
      "        unsigned long long floor_sum_unsigned(unsigned long long n,",
      "                                              unsigned long long m,",
      "                                              unsigned long long a,",
      "                                              unsigned long long b)",
      "        {",
      "            unsigned long long ans = 0;",
      "            while (true)",
      "            {",
      "                if (a >= m)",
      "                {",
      "                    ans += n * (n - 1) / 2 * (a / m);",
      "                    a %= m;",
      "                }",
      "                if (b >= m)",
      "                {",
      "                    ans += n * (b / m);",
      "                    b %= m;",
      "                }",
      "",
      "                unsigned long long y_max = a * n + b;",
      "                if (y_max < m)",
      "                    break;",
      "                n = (unsigned long long)(y_max / m);",
      "                b = (unsigned long long)(y_max % m);",
      "                std::swap(m, a);",
      "            }",
      "            return ans;",
      "        }",
      "",
      "    } // namespace internal",
      "",
      "} // namespace izano",
      "",
      "#include <cassert>",
      "#include <numeric>",
      "#include <type_traits>",
      "",
      "namespace izano",
      "{",
      "",
      "    namespace internal",
      "    {",
      "",
      "#ifndef _MSC_VER",
      "        template <class T>",
      "        using is_signed_int128 =",
      "            typename std::conditional<std::is_same<T, __int128_t>::value ||",
      "                                          std::is_same<T, __int128>::value,",
      "                                      std::true_type,",
      "                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using is_unsigned_int128 =",
      "            typename std::conditional<std::is_same<T, __uint128_t>::value ||",
      "                                          std::is_same<T, unsigned __int128>::value,",
      "                                      std::true_type,",
      "                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using make_unsigned_int128 =",
      "            typename std::conditional<std::is_same<T, __int128_t>::value,",
      "                                      __uint128_t,",
      "                                      unsigned __int128>;",
      "",
      "        template <class T>",
      "        using is_integral = typename std::conditional<std::is_integral<T>::value ||",
      "                                                          is_signed_int128<T>::value ||",
      "                                                          is_unsigned_int128<T>::value,",
      "                                                      std::true_type,",
      "                                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
      "                                                         std::is_signed<T>::value) ||",
      "                                                            is_signed_int128<T>::value,",
      "                                                        std::true_type,",
      "                                                        std::false_type>::type;",
      "",
      "        template <class T>",
      "        using is_unsigned_int =",
      "            typename std::conditional<(is_integral<T>::value &&",
      "                                       std::is_unsigned<T>::value) ||",
      "                                          is_unsigned_int128<T>::value,",
      "                                      std::true_type,",
      "                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using to_unsigned = typename std::conditional<",
      "            is_signed_int128<T>::value,",
      "            make_unsigned_int128<T>,",
      "            typename std::conditional<std::is_signed<T>::value,",
      "                                      std::make_unsigned<T>,",
      "                                      std::common_type<T>>::type>::type;",
      "",
      "#else",
      "",
      "        template <class T>",
      "        using is_integral = typename std::is_integral<T>;",
      "",
      "        template <class T>",
      "        using is_signed_int =",
      "            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
      "                                      std::true_type,",
      "                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using is_unsigned_int =",
      "            typename std::conditional<is_integral<T>::value &&",
      "                                          std::is_unsigned<T>::value,",
      "                                      std::true_type,",
      "                                      std::false_type>::type;",
      "",
      "        template <class T>",
      "        using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
      "                                                      std::make_unsigned<T>,",
      "                                                      std::common_type<T>>::type;",
      "",
      "#endif",
      "",
      "        template <class T>",
      "        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
      "",
      "        template <class T>",
      "        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
      "",
      "        template <class T>",
      "        using to_unsigned_t = typename to_unsigned<T>::type;",
      "",
      "    } // namespace internal",
      "",
      "} // namespace izano",
      "",
      "namespace izano",
      "{",
      "",
      "    namespace internal",
      "    {",
      "",
      "        struct modint_base",
      "        {",
      "        };",
      "        struct static_modint_base : modint_base",
      "        {",
      "        };",
      "",
      "        template <class T>",
      "        using is_modint = std::is_base_of<modint_base, T>;",
      "        template <class T>",
      "        using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
      "",
      "    } // namespace internal",
      "",
      "    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
      "    struct static_modint : internal::static_modint_base",
      "    {",
      "        using mint = static_modint;",
      "",
      "    public:",
      "        static constexpr int mod() { return m; }",
      "        static mint raw(int v)",
      "        {",
      "            mint x;",
      "            x._v = v;",
      "            return x;",
      "        }",
      "",
      "        static_modint() : _v(0) {}",
      "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
      "        static_modint(T v)",
      "        {",
      "            long long x = (long long)(v % (long long)(umod()));",
      "            if (x < 0)",
      "                x += umod();",
      "            _v = (unsigned int)(x);",
      "        }",
      "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
      "        static_modint(T v)",
      "        {",
      "            _v = (unsigned int)(v % umod());",
      "        }",
      "",
      "        unsigned int val() const { return _v; }",
      "",
      "        mint &operator++()",
      "        {",
      "            _v++;",
      "            if (_v == umod())",
      "                _v = 0;",
      "            return *this;",
      "        }",
      "        mint &operator--()",
      "        {",
      "            if (_v == 0)",
      "                _v = umod();",
      "            _v--;",
      "            return *this;",
      "        }",
      "        mint operator++(int)",
      "        {",
      "            mint result = *this;",
      "            ++*this;",
      "            return result;",
      "        }",
      "        mint operator--(int)",
      "        {",
      "            mint result = *this;",
      "            --*this;",
      "            return result;",
      "        }",
      "",
      "        mint &operator+=(const mint &rhs)",
      "        {",
      "            _v += rhs._v;",
      "            if (_v >= umod())",
      "                _v -= umod();",
      "            return *this;",
      "        }",
      "        mint &operator-=(const mint &rhs)",
      "        {",
      "            _v -= rhs._v;",
      "            if (_v >= umod())",
      "                _v += umod();",
      "            return *this;",
      "        }",
      "        mint &operator*=(const mint &rhs)",
      "        {",
      "            unsigned long long z = _v;",
      "            z *= rhs._v;",
      "            _v = (unsigned int)(z % umod());",
      "            return *this;",
      "        }",
      "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
      "",
      "        mint operator+() const { return *this; }",
      "        mint operator-() const { return mint() - *this; }",
      "",
      "        mint pow(long long n) const",
      "        {",
      "            assert(0 <= n);",
      "            mint x = *this, r = 1;",
      "            while (n)",
      "            {",
      "                if (n & 1)",
      "                    r *= x;",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            return r;",
      "        }",
      "        mint inv() const",
      "        {",
      "            if (prime)",
      "            {",
      "                assert(_v);",
      "                return pow(umod() - 2);",
      "            }",
      "            else",
      "            {",
      "                auto eg = internal::inv_gcd(_v, m);",
      "                assert(eg.first == 1);",
      "                return eg.second;",
      "            }",
      "        }",
      "",
      "        friend mint operator+(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) += rhs;",
      "        }",
      "        friend mint operator-(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) -= rhs;",
      "        }",
      "        friend mint operator*(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) *= rhs;",
      "        }",
      "        friend mint operator/(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) /= rhs;",
      "        }",
      "        friend bool operator==(const mint &lhs, const mint &rhs)",
      "        {",
      "            return lhs._v == rhs._v;",
      "        }",
      "        friend bool operator!=(const mint &lhs, const mint &rhs)",
      "        {",
      "            return lhs._v != rhs._v;",
      "        }",
      "",
      "    private:",
      "        unsigned int _v;",
      "        static constexpr unsigned int umod() { return m; }",
      "        static constexpr bool prime = internal::is_prime<m>;",
      "    };",
      "",
      "    template <int id>",
      "    struct dynamic_modint : internal::modint_base",
      "    {",
      "        using mint = dynamic_modint;",
      "",
      "    public:",
      "        static int mod() { return (int)(bt.umod()); }",
      "        static void set_mod(int m)",
      "        {",
      "            assert(1 <= m);",
      "            bt = internal::barrett(m);",
      "        }",
      "        static mint raw(int v)",
      "        {",
      "            mint x;",
      "            x._v = v;",
      "            return x;",
      "        }",
      "",
      "        dynamic_modint() : _v(0) {}",
      "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
      "        dynamic_modint(T v)",
      "        {",
      "            long long x = (long long)(v % (long long)(mod()));",
      "            if (x < 0)",
      "                x += mod();",
      "            _v = (unsigned int)(x);",
      "        }",
      "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
      "        dynamic_modint(T v)",
      "        {",
      "            _v = (unsigned int)(v % mod());",
      "        }",
      "",
      "        unsigned int val() const { return _v; }",
      "",
      "        mint &operator++()",
      "        {",
      "            _v++;",
      "            if (_v == umod())",
      "                _v = 0;",
      "            return *this;",
      "        }",
      "        mint &operator--()",
      "        {",
      "            if (_v == 0)",
      "                _v = umod();",
      "            _v--;",
      "            return *this;",
      "        }",
      "        mint operator++(int)",
      "        {",
      "            mint result = *this;",
      "            ++*this;",
      "            return result;",
      "        }",
      "        mint operator--(int)",
      "        {",
      "            mint result = *this;",
      "            --*this;",
      "            return result;",
      "        }",
      "",
      "        mint &operator+=(const mint &rhs)",
      "        {",
      "            _v += rhs._v;",
      "            if (_v >= umod())",
      "                _v -= umod();",
      "            return *this;",
      "        }",
      "        mint &operator-=(const mint &rhs)",
      "        {",
      "            _v += mod() - rhs._v;",
      "            if (_v >= umod())",
      "                _v -= umod();",
      "            return *this;",
      "        }",
      "        mint &operator*=(const mint &rhs)",
      "        {",
      "            _v = bt.mul(_v, rhs._v);",
      "            return *this;",
      "        }",
      "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
      "",
      "        mint operator+() const { return *this; }",
      "        mint operator-() const { return mint() - *this; }",
      "",
      "        mint pow(long long n) const",
      "        {",
      "            assert(0 <= n);",
      "            mint x = *this, r = 1;",
      "            while (n)",
      "            {",
      "                if (n & 1)",
      "                    r *= x;",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            return r;",
      "        }",
      "        mint inv() const",
      "        {",
      "            auto eg = internal::inv_gcd(_v, mod());",
      "            assert(eg.first == 1);",
      "            return eg.second;",
      "        }",
      "",
      "        friend mint operator+(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) += rhs;",
      "        }",
      "        friend mint operator-(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) -= rhs;",
      "        }",
      "        friend mint operator*(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) *= rhs;",
      "        }",
      "        friend mint operator/(const mint &lhs, const mint &rhs)",
      "        {",
      "            return mint(lhs) /= rhs;",
      "        }",
      "        friend bool operator==(const mint &lhs, const mint &rhs)",
      "        {",
      "            return lhs._v == rhs._v;",
      "        }",
      "        friend bool operator!=(const mint &lhs, const mint &rhs)",
      "        {",
      "            return lhs._v != rhs._v;",
      "        }",
      "",
      "    private:",
      "        unsigned int _v;",
      "        static internal::barrett bt;",
      "        static unsigned int umod() { return bt.umod(); }",
      "    };",
      "    template <int id>",
      "    internal::barrett dynamic_modint<id>::bt(998244353);",
      "",
      "    using modint998244353 = static_modint<998244353>;",
      "    using modint1000000007 = static_modint<1000000007>;",
      "    using modint = dynamic_modint<-1>;",
      "",
      "    namespace internal",
      "    {",
      "",
      "        template <class T>",
      "        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
      "",
      "        template <class T>",
      "        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
      "",
      "        template <class>",
      "        struct is_dynamic_modint : public std::false_type",
      "        {",
      "        };",
      "        template <int id>",
      "        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type",
      "        {",
      "        };",
      "",
      "        template <class T>",
      "        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
      "",
      "    } // namespace internal",
      "",
      "} // namespace izano",
      "",
      "using namespace izano;",
      "using mint = modint998244353;",
      "",
      "// mint fact(const int n)",
      "// {",
      "//     static vector<mint> v = {1};",
      "//     while ((int)v.size() <= n)",
      "//     {",
      "//         v.push_back(v.back() * v.size());",
      "//     }",
      "//     return v[n];",
      "// }",
      "",
      "// mint inv_fact(const int n)",
      "// {",
      "//     static vector<mint> u = {0, 1}, v = {1, 1};",
      "//     for (int i = (int)u.size(); i <= n; ++i)",
      "//     {",
      "//         u.push_back(-mint(mint::mod() / i) * u[mint::mod() % i]);",
      "//         v.push_back(v.back() * u.back());",
      "//     }",
      "//     return v[n];",
      "// }",
      "",
      "// mint binom(const int n, const int k) {",
      "//     return fact(n) * inv_fact(k) * inv_fact(n - k);",
      "// }"
    ],
    "description": "Modulo Arithmetic implementation Snippet"
  },
  "fenwicktree": {
    "prefix": "fenwicktree",
    "body": [
      "namespace izano {",
      "",
      "namespace internal {",
      "",
      "#ifndef _MSC_VER",
      "template <class T>",
      "using is_signed_int128 =",
      "    typename std::conditional<std::is_same<T, __int128_t>::value ||",
      "                                  std::is_same<T, __int128>::value,",
      "                              std::true_type,",
      "                              std::false_type>::type;",
      "",
      "template <class T>",
      "using is_unsigned_int128 =",
      "    typename std::conditional<std::is_same<T, __uint128_t>::value ||",
      "                                  std::is_same<T, unsigned __int128>::value,",
      "                              std::true_type,",
      "                              std::false_type>::type;",
      "",
      "template <class T>",
      "using make_unsigned_int128 =",
      "    typename std::conditional<std::is_same<T, __int128_t>::value,",
      "                              __uint128_t,",
      "                              unsigned __int128>;",
      "",
      "template <class T>",
      "using is_integral = typename std::conditional<std::is_integral<T>::value ||",
      "                                                  is_signed_int128<T>::value ||",
      "                                                  is_unsigned_int128<T>::value,",
      "                                              std::true_type,",
      "                                              std::false_type>::type;",
      "",
      "template <class T>",
      "using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
      "                                                 std::is_signed<T>::value) ||",
      "                                                    is_signed_int128<T>::value,",
      "                                                std::true_type,",
      "                                                std::false_type>::type;",
      "",
      "template <class T>",
      "using is_unsigned_int =",
      "    typename std::conditional<(is_integral<T>::value &&",
      "                               std::is_unsigned<T>::value) ||",
      "                                  is_unsigned_int128<T>::value,",
      "                              std::true_type,",
      "                              std::false_type>::type;",
      "",
      "template <class T>",
      "using to_unsigned = typename std::conditional<",
      "    is_signed_int128<T>::value,",
      "    make_unsigned_int128<T>,",
      "    typename std::conditional<std::is_signed<T>::value,",
      "                              std::make_unsigned<T>,",
      "                              std::common_type<T>>::type>::type;",
      "",
      "#else",
      "",
      "template <class T> using is_integral = typename std::is_integral<T>;",
      "",
      "template <class T>",
      "using is_signed_int =",
      "    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
      "                              std::true_type,",
      "                              std::false_type>::type;",
      "",
      "template <class T>",
      "using is_unsigned_int =",
      "    typename std::conditional<is_integral<T>::value &&",
      "                                  std::is_unsigned<T>::value,",
      "                              std::true_type,",
      "                              std::false_type>::type;",
      "",
      "template <class T>",
      "using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
      "                                              std::make_unsigned<T>,",
      "                                              std::common_type<T>>::type;",
      "",
      "#endif",
      "",
      "template <class T>",
      "using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
      "",
      "template <class T>",
      "using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
      "",
      "template <class T> using to_unsigned_t = typename to_unsigned<T>::type;",
      "",
      "}  // namespace internal",
      "",
      "}  // namespace izano",
      "",
      "",
      "namespace izano {",
      "",
      "template <class T> struct fenwick_tree {",
      "    using U = internal::to_unsigned_t<T>;",
      "",
      "  public:",
      "    fenwick_tree() : _n(0) {}",
      "    explicit fenwick_tree(int n) : _n(n), data(n) {}",
      "",
      "    void add(int p, T x) {",
      "        assert(0 <= p && p < _n);",
      "        p++;",
      "        while (p <= _n) {",
      "            data[p - 1] += U(x);",
      "            p += p & -p;",
      "        }",
      "    }",
      "",
      "    T sum(int l, int r) {",
      "        assert(0 <= l && l <= r && r <= _n);",
      "        return sum(r) - sum(l);",
      "    }",
      "",
      "  private:",
      "    int _n;",
      "    std::vector<U> data;",
      "",
      "    U sum(int r) {",
      "        U s = 0;",
      "        while (r > 0) {",
      "            s += data[r - 1];",
      "            r -= r & -r;",
      "        }",
      "        return s;",
      "    }",
      "};",
      "",
      "}  // namespace izano",
      "",
      "using namespace izano;"
    ],
    "description": "Fenwick tree implementation snippet"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "namespace izano {",
      "",
      "struct dsu {",
      "  public:",
      "    dsu() : _n(0) {}",
      "    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}",
      "",
      "    int merge(int a, int b) {",
      "        assert(0 <= a && a < _n);",
      "        assert(0 <= b && b < _n);",
      "        int x = leader(a), y = leader(b);",
      "        if (x == y) return x;",
      "        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);",
      "        parent_or_size[x] += parent_or_size[y];",
      "        parent_or_size[y] = x;",
      "        return x;",
      "    }",
      "",
      "    bool same(int a, int b) {",
      "        assert(0 <= a && a < _n);",
      "        assert(0 <= b && b < _n);",
      "        return leader(a) == leader(b);",
      "    }",
      "",
      "    int leader(int a) {",
      "        assert(0 <= a && a < _n);",
      "        if (parent_or_size[a] < 0) return a;",
      "        return parent_or_size[a] = leader(parent_or_size[a]);",
      "    }",
      "",
      "    int size(int a) {",
      "        assert(0 <= a && a < _n);",
      "        return -parent_or_size[leader(a)];",
      "    }",
      "",
      "    std::vector<std::vector<int>> groups() {",
      "        std::vector<int> leader_buf(_n), group_size(_n);",
      "        for (int i = 0; i < _n; i++) {",
      "            leader_buf[i] = leader(i);",
      "            group_size[leader_buf[i]]++;",
      "        }",
      "        std::vector<std::vector<int>> result(_n);",
      "        for (int i = 0; i < _n; i++) {",
      "            result[i].reserve(group_size[i]);",
      "        }",
      "        for (int i = 0; i < _n; i++) {",
      "            result[leader_buf[i]].push_back(i);",
      "        }",
      "        result.erase(",
      "            std::remove_if(result.begin(), result.end(),",
      "                           [&](const std::vector<int>& v) { return v.empty(); }),",
      "            result.end());",
      "        return result;",
      "    }",
      "",
      "  private:",
      "    int _n;",
      "    std::vector<int> parent_or_size;",
      "};",
      "",
      "}  // namespace izano",
      "",
      "using namespace izano;"
    ],
    "description": "Disjoint Set Union implementation snippet"
  },
  "mysplstring": {
    "prefix": "mysplstring",
    "body": [
      "namespace izano {",
      "",
      "namespace internal {",
      "",
      "std::vector<int> sa_naive(const std::vector<int>& s) {",
      "    int n = int(s.size());",
      "    std::vector<int> sa(n);",
      "    std::iota(sa.begin(), sa.end(), 0);",
      "    std::sort(sa.begin(), sa.end(), [&](int l, int r) {",
      "        if (l == r) return false;",
      "        while (l < n && r < n) {",
      "            if (s[l] != s[r]) return s[l] < s[r];",
      "            l++;",
      "            r++;",
      "        }",
      "        return l == n;",
      "    });",
      "    return sa;",
      "}",
      "",
      "std::vector<int> sa_doubling(const std::vector<int>& s) {",
      "    int n = int(s.size());",
      "    std::vector<int> sa(n), rnk = s, tmp(n);",
      "    std::iota(sa.begin(), sa.end(), 0);",
      "    for (int k = 1; k < n; k *= 2) {",
      "        auto cmp = [&](int x, int y) {",
      "            if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
      "            int rx = x + k < n ? rnk[x + k] : -1;",
      "            int ry = y + k < n ? rnk[y + k] : -1;",
      "            return rx < ry;",
      "        };",
      "        std::sort(sa.begin(), sa.end(), cmp);",
      "        tmp[sa[0]] = 0;",
      "        for (int i = 1; i < n; i++) {",
      "            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
      "        }",
      "        std::swap(tmp, rnk);",
      "    }",
      "    return sa;",
      "}",
      "",
      "template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>",
      "std::vector<int> sa_is(const std::vector<int>& s, int upper) {",
      "    int n = int(s.size());",
      "    if (n == 0) return {};",
      "    if (n == 1) return {0};",
      "    if (n == 2) {",
      "        if (s[0] < s[1]) {",
      "            return {0, 1};",
      "        } else {",
      "            return {1, 0};",
      "        }",
      "    }",
      "    if (n < THRESHOLD_NAIVE) {",
      "        return sa_naive(s);",
      "    }",
      "    if (n < THRESHOLD_DOUBLING) {",
      "        return sa_doubling(s);",
      "    }",
      "",
      "    std::vector<int> sa(n);",
      "    std::vector<bool> ls(n);",
      "    for (int i = n - 2; i >= 0; i--) {",
      "        ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
      "    }",
      "    std::vector<int> sum_l(upper + 1), sum_s(upper + 1);",
      "    for (int i = 0; i < n; i++) {",
      "        if (!ls[i]) {",
      "            sum_s[s[i]]++;",
      "        } else {",
      "            sum_l[s[i] + 1]++;",
      "        }",
      "    }",
      "    for (int i = 0; i <= upper; i++) {",
      "        sum_s[i] += sum_l[i];",
      "        if (i < upper) sum_l[i + 1] += sum_s[i];",
      "    }",
      "",
      "    auto induce = [&](const std::vector<int>& lms) {",
      "        std::fill(sa.begin(), sa.end(), -1);",
      "        std::vector<int> buf(upper + 1);",
      "        std::copy(sum_s.begin(), sum_s.end(), buf.begin());",
      "        for (auto d : lms) {",
      "            if (d == n) continue;",
      "            sa[buf[s[d]]++] = d;",
      "        }",
      "        std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
      "        sa[buf[s[n - 1]]++] = n - 1;",
      "        for (int i = 0; i < n; i++) {",
      "            int v = sa[i];",
      "            if (v >= 1 && !ls[v - 1]) {",
      "                sa[buf[s[v - 1]]++] = v - 1;",
      "            }",
      "        }",
      "        std::copy(sum_l.begin(), sum_l.end(), buf.begin());",
      "        for (int i = n - 1; i >= 0; i--) {",
      "            int v = sa[i];",
      "            if (v >= 1 && ls[v - 1]) {",
      "                sa[--buf[s[v - 1] + 1]] = v - 1;",
      "            }",
      "        }",
      "    };",
      "",
      "    std::vector<int> lms_map(n + 1, -1);",
      "    int m = 0;",
      "    for (int i = 1; i < n; i++) {",
      "        if (!ls[i - 1] && ls[i]) {",
      "            lms_map[i] = m++;",
      "        }",
      "    }",
      "    std::vector<int> lms;",
      "    lms.reserve(m);",
      "    for (int i = 1; i < n; i++) {",
      "        if (!ls[i - 1] && ls[i]) {",
      "            lms.push_back(i);",
      "        }",
      "    }",
      "",
      "    induce(lms);",
      "",
      "    if (m) {",
      "        std::vector<int> sorted_lms;",
      "        sorted_lms.reserve(m);",
      "        for (int v : sa) {",
      "            if (lms_map[v] != -1) sorted_lms.push_back(v);",
      "        }",
      "        std::vector<int> rec_s(m);",
      "        int rec_upper = 0;",
      "        rec_s[lms_map[sorted_lms[0]]] = 0;",
      "        for (int i = 1; i < m; i++) {",
      "            int l = sorted_lms[i - 1], r = sorted_lms[i];",
      "            int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
      "            int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
      "            bool same = true;",
      "            if (end_l - l != end_r - r) {",
      "                same = false;",
      "            } else {",
      "                while (l < end_l) {",
      "                    if (s[l] != s[r]) {",
      "                        break;",
      "                    }",
      "                    l++;",
      "                    r++;",
      "                }",
      "                if (l == n || s[l] != s[r]) same = false;",
      "            }",
      "            if (!same) rec_upper++;",
      "            rec_s[lms_map[sorted_lms[i]]] = rec_upper;",
      "        }",
      "",
      "        auto rec_sa =",
      "            sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);",
      "",
      "        for (int i = 0; i < m; i++) {",
      "            sorted_lms[i] = lms[rec_sa[i]];",
      "        }",
      "        induce(sorted_lms);",
      "    }",
      "    return sa;",
      "}",
      "",
      "}  // namespace internal",
      "",
      "std::vector<int> suffix_array(const std::vector<int>& s, int upper) {",
      "    assert(0 <= upper);",
      "    for (int d : s) {",
      "        assert(0 <= d && d <= upper);",
      "    }",
      "    auto sa = internal::sa_is(s, upper);",
      "    return sa;",
      "}",
      "",
      "template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {",
      "    int n = int(s.size());",
      "    std::vector<int> idx(n);",
      "    iota(idx.begin(), idx.end(), 0);",
      "    sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });",
      "    std::vector<int> s2(n);",
      "    int now = 0;",
      "    for (int i = 0; i < n; i++) {",
      "        if (i && s[idx[i - 1]] != s[idx[i]]) now++;",
      "        s2[idx[i]] = now;",
      "    }",
      "    return internal::sa_is(s2, now);",
      "}",
      "",
      "std::vector<int> suffix_array(const std::string& s) {",
      "    int n = int(s.size());",
      "    std::vector<int> s2(n);",
      "    for (int i = 0; i < n; i++) {",
      "        s2[i] = s[i];",
      "    }",
      "    return internal::sa_is(s2, 255);",
      "}",
      "",
      "template <class T>",
      "std::vector<int> lcp_array(const std::vector<T>& s,",
      "                           const std::vector<int>& sa) {",
      "    int n = int(s.size());",
      "    assert(n >= 1);",
      "    std::vector<int> rnk(n);",
      "    for (int i = 0; i < n; i++) {",
      "        rnk[sa[i]] = i;",
      "    }",
      "    std::vector<int> lcp(n - 1);",
      "    int h = 0;",
      "    for (int i = 0; i < n; i++) {",
      "        if (h > 0) h--;",
      "        if (rnk[i] == 0) continue;",
      "        int j = sa[rnk[i] - 1];",
      "        for (; j + h < n && i + h < n; h++) {",
      "            if (s[j + h] != s[i + h]) break;",
      "        }",
      "        lcp[rnk[i] - 1] = h;",
      "    }",
      "    return lcp;",
      "}",
      "",
      "std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {",
      "    int n = int(s.size());",
      "    std::vector<int> s2(n);",
      "    for (int i = 0; i < n; i++) {",
      "        s2[i] = s[i];",
      "    }",
      "    return lcp_array(s2, sa);",
      "}",
      "",
      "template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {",
      "    int n = int(s.size());",
      "    if (n == 0) return {};",
      "    std::vector<int> z(n);",
      "    z[0] = 0;",
      "    for (int i = 1, j = 0; i < n; i++) {",
      "        int& k = z[i];",
      "        k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);",
      "        while (i + k < n && s[k] == s[i + k]) k++;",
      "        if (j + z[j] < i + z[i]) j = i;",
      "    }",
      "    z[0] = n;",
      "    return z;",
      "}",
      "",
      "std::vector<int> z_algorithm(const std::string& s) {",
      "    int n = int(s.size());",
      "    std::vector<int> s2(n);",
      "    for (int i = 0; i < n; i++) {",
      "        s2[i] = s[i];",
      "    }",
      "    return z_algorithm(s2);",
      "}",
      "",
      "}  // namespace izano",
      "",
      "using namespace izano;"
    ],
    "description": "String suffix array/LCP/z-algorithm implementation snippet"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "#ifdef _MSC_VER",
      "#include <intrin.h>",
      "#endif",
      "",
      "namespace izano {",
      "",
      "namespace internal {",
      "",
      "int ceil_pow2(int n) {",
      "    int x = 0;",
      "    while ((1U << x) < (unsigned int)(n)) x++;",
      "    return x;",
      "}",
      "",
      "constexpr int bsf_constexpr(unsigned int n) {",
      "    int x = 0;",
      "    while (!(n & (1 << x))) x++;",
      "    return x;",
      "}",
      "",
      "int bsf(unsigned int n) {",
      "#ifdef _MSC_VER",
      "    unsigned long index;",
      "    _BitScanForward(&index, n);",
      "    return index;",
      "#else",
      "    return __builtin_ctz(n);",
      "#endif",
      "}",
      "",
      "}  // namespace internal",
      "",
      "}  // namespace izano",
      "",
      "",
      "namespace izano {",
      "",
      "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
      "  public:",
      "    segtree() : segtree(0) {}",
      "    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}",
      "    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {",
      "        log = internal::ceil_pow2(_n);",
      "        size = 1 << log;",
      "        d = std::vector<S>(2 * size, e());",
      "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
      "        for (int i = size - 1; i >= 1; i--) {",
      "            update(i);",
      "        }",
      "    }",
      "",
      "    void set(int p, S x) {",
      "        assert(0 <= p && p < _n);",
      "        p += size;",
      "        d[p] = x;",
      "        for (int i = 1; i <= log; i++) update(p >> i);",
      "    }",
      "",
      "    S get(int p) const {",
      "        assert(0 <= p && p < _n);",
      "        return d[p + size];",
      "    }",
      "",
      "    S prod(int l, int r) const {",
      "        assert(0 <= l && l <= r && r <= _n);",
      "        S sml = e(), smr = e();",
      "        l += size;",
      "        r += size;",
      "",
      "        while (l < r) {",
      "            if (l & 1) sml = op(sml, d[l++]);",
      "            if (r & 1) smr = op(d[--r], smr);",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        return op(sml, smr);",
      "    }",
      "",
      "    S all_prod() const { return d[1]; }",
      "",
      "    template <bool (*f)(S)> int max_right(int l) const {",
      "        return max_right(l, [](S x) { return f(x); });",
      "    }",
      "    template <class F> int max_right(int l, F f) const {",
      "        assert(0 <= l && l <= _n);",
      "        assert(f(e()));",
      "        if (l == _n) return _n;",
      "        l += size;",
      "        S sm = e();",
      "        do {",
      "            while (l % 2 == 0) l >>= 1;",
      "            if (!f(op(sm, d[l]))) {",
      "                while (l < size) {",
      "                    l = (2 * l);",
      "                    if (f(op(sm, d[l]))) {",
      "                        sm = op(sm, d[l]);",
      "                        l++;",
      "                    }",
      "                }",
      "                return l - size;",
      "            }",
      "            sm = op(sm, d[l]);",
      "            l++;",
      "        } while ((l & -l) != l);",
      "        return _n;",
      "    }",
      "",
      "    template <bool (*f)(S)> int min_left(int r) const {",
      "        return min_left(r, [](S x) { return f(x); });",
      "    }",
      "    template <class F> int min_left(int r, F f) const {",
      "        assert(0 <= r && r <= _n);",
      "        assert(f(e()));",
      "        if (r == 0) return 0;",
      "        r += size;",
      "        S sm = e();",
      "        do {",
      "            r--;",
      "            while (r > 1 && (r % 2)) r >>= 1;",
      "            if (!f(op(d[r], sm))) {",
      "                while (r < size) {",
      "                    r = (2 * r + 1);",
      "                    if (f(op(d[r], sm))) {",
      "                        sm = op(d[r], sm);",
      "                        r--;",
      "                    }",
      "                }",
      "                return r + 1 - size;",
      "            }",
      "            sm = op(d[r], sm);",
      "        } while ((r & -r) != r);",
      "        return 0;",
      "    }",
      "",
      "  private:",
      "    int _n, size, log;",
      "    std::vector<S> d;",
      "",
      "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "};",
      "",
      "}  // namespace izano",
      "",
      "using namespace izano;"
    ],
    "description": "Segment tree implementation snippet"
  },
  "scc": {
    "prefix": "scc",
    "body": [
      "namespace izano {",
      "namespace internal {",
      "",
      "template <class E> struct csr {",
      "    std::vector<int> start;",
      "    std::vector<E> elist;",
      "    explicit csr(int n, const std::vector<std::pair<int, E>>& edges)",
      "        : start(n + 1), elist(edges.size()) {",
      "        for (auto e : edges) {",
      "            start[e.first + 1]++;",
      "        }",
      "        for (int i = 1; i <= n; i++) {",
      "            start[i] += start[i - 1];",
      "        }",
      "        auto counter = start;",
      "        for (auto e : edges) {",
      "            elist[counter[e.first]++] = e.second;",
      "        }",
      "    }",
      "};",
      "",
      "}  // namespace internal",
      "",
      "}  // namespace izano",
      "",
      "",
      "namespace izano {",
      "namespace internal {",
      "",
      "struct scc_graph {",
      "  public:",
      "    explicit scc_graph(int n) : _n(n) {}",
      "",
      "    int num_vertices() { return _n; }",
      "",
      "    void add_edge(int from, int to) { edges.push_back({from, {to}}); }",
      "",
      "    std::pair<int, std::vector<int>> scc_ids() {",
      "        auto g = csr<edge>(_n, edges);",
      "        int now_ord = 0, group_num = 0;",
      "        std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);",
      "        visited.reserve(_n);",
      "        auto dfs = [&](auto self, int v) -> void {",
      "            low[v] = ord[v] = now_ord++;",
      "            visited.push_back(v);",
      "            for (int i = g.start[v]; i < g.start[v + 1]; i++) {",
      "                auto to = g.elist[i].to;",
      "                if (ord[to] == -1) {",
      "                    self(self, to);",
      "                    low[v] = std::min(low[v], low[to]);",
      "                } else {",
      "                    low[v] = std::min(low[v], ord[to]);",
      "                }",
      "            }",
      "            if (low[v] == ord[v]) {",
      "                while (true) {",
      "                    int u = visited.back();",
      "                    visited.pop_back();",
      "                    ord[u] = _n;",
      "                    ids[u] = group_num;",
      "                    if (u == v) break;",
      "                }",
      "                group_num++;",
      "            }",
      "        };",
      "        for (int i = 0; i < _n; i++) {",
      "            if (ord[i] == -1) dfs(dfs, i);",
      "        }",
      "        for (auto& x : ids) {",
      "            x = group_num - 1 - x;",
      "        }",
      "        return {group_num, ids};",
      "    }",
      "",
      "    std::vector<std::vector<int>> scc() {",
      "        auto ids = scc_ids();",
      "        int group_num = ids.first;",
      "        std::vector<int> counts(group_num);",
      "        for (auto x : ids.second) counts[x]++;",
      "        std::vector<std::vector<int>> groups(ids.first);",
      "        for (int i = 0; i < group_num; i++) {",
      "            groups[i].reserve(counts[i]);",
      "        }",
      "        for (int i = 0; i < _n; i++) {",
      "            groups[ids.second[i]].push_back(i);",
      "        }",
      "        return groups;",
      "    }",
      "",
      "  private:",
      "    int _n;",
      "    struct edge {",
      "        int to;",
      "    };",
      "    std::vector<std::pair<int, edge>> edges;",
      "};",
      "",
      "}  // namespace internal",
      "",
      "}  // namespace izano",
      "",
      "",
      "namespace izano {",
      "",
      "struct scc_graph {",
      "  public:",
      "    scc_graph() : internal(0) {}",
      "    explicit scc_graph(int n) : internal(n) {}",
      "",
      "    void add_edge(int from, int to) {",
      "        int n = internal.num_vertices();",
      "        assert(0 <= from && from < n);",
      "        assert(0 <= to && to < n);",
      "        internal.add_edge(from, to);",
      "    }",
      "",
      "    std::vector<std::vector<int>> scc() { return internal.scc(); }",
      "",
      "  private:",
      "    internal::scc_graph internal;",
      "};",
      "",
      "}  // namespace izano",
      "",
      "using namespace izano;"
    ],
    "description": "Strongly connected component implementation snippet"
  },
  "modmint": {
    "prefix": "modmint",
    "body": [
      "const uint MOD = 998244353;",
      "template <uint mod = MOD>",
      "struct mint",
      "{ // 1000000007  1000000009",
      "    uint x;",
      "",
      "    mint() : x(0) {}",
      "    mint(ll _x)",
      "    {",
      "        _x %= mod;",
      "        if (_x < 0)",
      "            _x += mod;",
      "        x = _x;",
      "    }",
      "",
      "    mint &operator+=(const mint &a)",
      "    {",
      "        x += a.x;",
      "        if (x >= mod)",
      "            x -= mod;",
      "        return *this;",
      "    }",
      "    mint &operator-=(const mint &a)",
      "    {",
      "        x += mod - a.x;",
      "        if (x >= mod)",
      "            x -= mod;",
      "        return *this;",
      "    }",
      "    mint &operator*=(const mint &a)",
      "    {",
      "        x = (ull)x * a.x % mod;",
      "        return *this;",
      "    }",
      "    mint pow(ll pw) const",
      "    {",
      "        mint res = 1;",
      "        mint cur = *this;",
      "        while (pw)",
      "        {",
      "            if (pw & 1)",
      "                res *= cur;",
      "            cur *= cur;",
      "            pw >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "    mint inv() const",
      "    {",
      "        assert(x != 0);",
      "        uint t = x;",
      "        uint res = 1;",
      "        while (t != 1)",
      "        {",
      "            uint z = mod / t;",
      "            res = (ull)res * (mod - z) % mod;",
      "            t = mod - t * z;",
      "        }",
      "        return res;",
      "    }",
      "    mint &operator/=(const mint &a)",
      "    {",
      "        return *this *= a.inv();",
      "    }",
      "    mint operator+(const mint &a) const",
      "    {",
      "        return mint(*this) += a;",
      "    }",
      "    mint operator-(const mint &a) const",
      "    {",
      "        return mint(*this) -= a;",
      "    }",
      "    mint operator*(const mint &a) const",
      "    {",
      "        return mint(*this) *= a;",
      "    }",
      "    mint operator/(const mint &a) const",
      "    {",
      "        return mint(*this) /= a;",
      "    }",
      "",
      "    bool sqrt(mint &res) const",
      "    {",
      "        if (mod == 2 || x == 0)",
      "        {",
      "            res = *this;",
      "            return true;",
      "        }",
      "        if (pow((mod - 1) / 2) != 1)",
      "            return false;",
      "        if (mod % 4 == 3)",
      "        {",
      "            res = pow((mod + 1) / 4);",
      "            return true;",
      "        }",
      "        int pw = (mod - 1) / 2;",
      "        int K = 30;",
      "        while ((1 << K) > pw)",
      "            K--;",
      "        while (true)",
      "        {",
      "            mint t = myRand(mod);",
      "            mint a = 0, b = 0, c = 1;",
      "            for (int k = K; k >= 0; k--)",
      "            {",
      "                a = b * b;",
      "                b = b * c * 2;",
      "                c = c * c + a * *this;",
      "                if (((pw >> k) & 1) == 0)",
      "                    continue;",
      "                a = b;",
      "                b = b * t + c;",
      "                c = c * t + a * *this;",
      "            }",
      "            if (b == 0)",
      "                continue;",
      "            c -= 1;",
      "            c *= mint() - b.inv();",
      "            if (c * c == *this)",
      "            {",
      "                res = c;",
      "                return true;",
      "            }",
      "        }",
      "        assert(false);",
      "    }",
      "",
      "    bool operator==(const mint &a) const",
      "    {",
      "        return x == a.x;",
      "    }",
      "    bool operator!=(const mint &a) const",
      "    {",
      "        return x != a.x;",
      "    }",
      "    bool operator<(const mint &a) const",
      "    {",
      "        return x < a.x;",
      "    }",
      "};",
      "template <uint mod = MOD>",
      "struct Factorials",
      "{",
      "    using Mint = mint<mod>;",
      "    vector<Mint> f, fi;",
      "",
      "    Factorials() : f(), fi() {}",
      "    Factorials(int n)",
      "    {",
      "        n += 10;",
      "        f = vector<Mint>(n);",
      "        fi = vector<Mint>(n);",
      "        f[0] = 1;",
      "        for (int i = 1; i < n; i++)",
      "            f[i] = f[i - 1] * i;",
      "        fi[n - 1] = f[n - 1].inv();",
      "        for (int i = n - 1; i > 0; i--)",
      "            fi[i - 1] = fi[i] * i;",
      "    }",
      "",
      "    Mint C(int n, int k)",
      "    {",
      "        if (k < 0 || k > n)",
      "            return 0;",
      "        return f[n] * fi[k] * fi[n - k];",
      "    }",
      "};",
      "template <uint mod = MOD>",
      "struct Powers",
      "{",
      "    using Mint = mint<mod>;",
      "    vector<Mint> p, pi;",
      "",
      "    Powers() : p(), pi() {}",
      "    Powers(int n, Mint x)",
      "    {",
      "        n += 10;",
      "        if (x == 0)",
      "        {",
      "            p = vector<Mint>(n);",
      "            p[0] = 1;",
      "        }",
      "        else",
      "        {",
      "            p = vector<Mint>(n);",
      "            pi = vector<Mint>(n);",
      "            p[0] = pi[0] = 1;",
      "            Mint xi = x.inv();",
      "            for (int i = 1; i < n; i++)",
      "            {",
      "                p[i] = p[i - 1] * x;",
      "                pi[i] = pi[i - 1] * xi;",
      "            }",
      "        }",
      "    }",
      "",
      "    Mint pow(int n)",
      "    {",
      "        if (n >= 0)",
      "            return p[n];",
      "        else",
      "            return pi[-n];",
      "    }",
      "};",
      "template <uint mod = MOD>",
      "struct Inverses",
      "{",
      "    using Mint = mint<mod>;",
      "    vector<Mint> ii;",
      "",
      "    Inverses() : ii() {}",
      "    Inverses(int n)",
      "    {",
      "        n += 10;",
      "        ii = vector<Mint>(n);",
      "        ii[1] = 1;",
      "        for (int x = 2; x < n; x++)",
      "            ii[x] = Mint() - ii[mod % x] * (mod / x);",
      "    }",
      "",
      "    Mint inv(Mint x)",
      "    {",
      "        assert(x != 0);",
      "        uint t = x.x;",
      "        uint res = 1;",
      "        while (t >= (int)ii.size())",
      "        {",
      "            uint z = mod / t;",
      "            res = (ull)res * (mod - z) % mod;",
      "            t = mod - t * z;",
      "        }",
      "        return ii[t] * res;",
      "    }",
      "};",
      "using Mint = mint<>;"
    ],
    "description": "modmint"
  },
  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T>",
      "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ],
    "description": "pbds"
  }
}
